#include "lib9.h"
#include "isa.h"
#include "interp.h"

void	decgen(int);

/*
 * Force intermediate dereference of $o(o(reg)) modes to ensure intermediate
 * pointer is valid. This is required if you want secure memory.
 */
#define	SOFTMMU		0

int
main(void)
{
	int i;

	print("/* Machine generated by decgen.c */\n\n");

	print("#include <lib9.h>\n");
	print("#include <isa.h>\n");
	print("#include <interp.h>\n\n");
	print("#include <raise.h>\n\n");

	print("\nvoid dec(Dec* r, const Inst* PC, void* MP, Frame* FP) {\n");

	print("switch(PC->add) {\n");
	for(i = 0; i < 256; i++)
		decgen(i);
	print("};\n");

	print("};\n");

	return 0;
}

void
decgen(int addr)
{
	int nodst;

//	print("static void \nD%.2uX(Dec*r, const Inst* PC, void* MP, Frame* FP)\n{\n", addr);
	print("case %d:\n", addr);

	switch(USRC(addr)) {
	case AMP:
		print("\tr->s = (Disdata*) ((char*)MP + PC->s.ind);\n");
		break;
	case AFP:
		print("\tr->s = (Disdata*) ((char*)FP + PC->s.ind);\n");
		break;
	case AIMM:
		print("\tr->s = (Disdata*) &PC->s.imm;\n");
		break;
	case AMP|AIND:
		if(SOFTMMU) {
			print("R.s = (Disdata*) ((char*)R.MP + R.PC->s.i.f)\n");
			print("R.s = R.s->pdisdata\n");
			print("R.s = (Disdata*) ((char*)R.s + R.PC->s.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)MP + PC->s.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t r->s = (Disdata*) (x + PC->s.i.s);}\n");
		}
		break;
	case AFP|AIND:
		if(SOFTMMU) {
			print("R.s = (Disdata*) ((char*)R.FP + R.PC->s.i.f)\n");
			print("R.s = R.s->pdisdata\n");
			print("R.s = (Disdata*) ((char*)R.s + R.PC->s.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)FP + PC->s.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t r->s = (Disdata*) (x + PC->s.i.s);}\n");
		}
		break;
	}
	nodst = 0;
	switch(UDST(addr)) {
	default:
		nodst = 1;
		break;
	case AMP:
		print("\tr->d = (Disdata*) ((char*)MP + PC->d.ind);\n");
		break;
	case AFP:
		print("\tr->d = (Disdata*) ((char*)FP + PC->d.ind);\n");
		break;
	case AIMM:
		print("\tr->d = (Disdata*) &PC->d.imm;\n");
		break;
	case AMP|AIND:
		if(SOFTMMU) {
			print("R.d = (Disdata*) ((char*)R.MP + R.PC->d.i.f)\n");
			print("R.d = *(WORD**)R.d\n");
			print("R.d = (Disdata*) ((char*)R.d + R.PC->d.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)MP + PC->d.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t r->d = (Disdata*) (x + PC->d.i.s);}\n");
		}
		break;
	case AFP|AIND:
		if(SOFTMMU) {
			print("R.d = (Disdata*) ((char*)R.FP + R.PC->d.i.f)\n");
			print("R.d = *(WORD**)R.d\n");
			print("R.d = (Disdata*) ((char*)R.d + R.PC->d.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)FP + PC->d.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t r->d = (Disdata*) (x + PC->d.i.s);}\n");
		}
		break;
	}

	if(nodst == 0)
	switch(addr&ARM) {
	case AXNON:
		print("\tr->m = r->d;\n");
		break;
	case AXIMM:
		print("\tr->tmp = (short) PC->reg;\n");
		print("\tr->m = (Disdata*) &r->tmp;\n");
		break;
	case AXINF:
		print("\tr->m = (Disdata*) ((char*)FP + PC->reg);\n");
		break;
	case AXINM:
		print("\tr->m = (Disdata*) ((char*)MP + PC->reg);\n");
		break;
	}
	print("\tbreak;\n");
}
