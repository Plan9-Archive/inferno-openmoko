#include "lib9.h"
#include "isa.h"
#include "interp.h"

void	decgen(int);

/*
 * Force intermediate dereference of $o(o(reg)) modes to ensure intermediate
 * pointer is valid. This is required if you want secure memory.
 */
#define	SOFTMMU		0

int
main(void)
{
	int i;

	print("/* Machine generated by decgen.c */\n\n");

	print("#include \"lib9.h\"\n");
	print("#include \"isa.h\"\n");
	print("#include \"interp.h\"\n\n");
	print("#include \"raise.h\"\n\n");
	print("extern REG R;\n\n");

	for(i = 0; i < 256; i++)
		decgen(i);

	print("\nvoid	(*dec[])(void) =\n{\n");
	for(i = 0; i < 256; i++)
		print("\tD%.2uX%c\n", i, i != 255 ? ',' : ' ');
	print("};\n");
	return 0;
}

void
decgen(int addr)
{
	int nodst;

	print("static void\nD%.2uX(void)\n{\n", addr);

	switch(USRC(addr)) {
	case AMP:
		print("\tR.s = (Disdata*) ((char*)R.MP + R.PC->s.ind);\n");
		break;
	case AFP:
		print("\tR.s = (Disdata*) ((char*)R.FP + R.PC->s.ind);\n");
		break;
	case AIMM:
		print("\tR.s = (Disdata*) &R.PC->s.imm;\n");
		break;
	case AMP|AIND:
		if(SOFTMMU) {
			print("R.s = (Disdata*) ((char*)R.MP + R.PC->s.i.f)\n");
			print("R.s = R.s->pdisdata\n");
			print("R.s = (Disdata*) ((char*)R.s + R.PC->s.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)R.MP + R.PC->s.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t R.s = (Disdata*) (x + R.PC->s.i.s);}\n");
		}
		break;
	case AFP|AIND:
		if(SOFTMMU) {
			print("R.s = (Disdata*) ((char*)R.FP + R.PC->s.i.f)\n");
			print("R.s = R.s->pdisdata\n");
			print("R.s = (Disdata*) ((char*)R.s + R.PC->s.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)R.FP + R.PC->s.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t R.s = (Disdata*) (x + R.PC->s.i.s);}\n");
		}
		break;
	}
	nodst = 0;
	switch(UDST(addr)) {
	default:
		nodst = 1;
		break;
	case AMP:
		print("\tR.d = (Disdata*) ((char*)R.MP + R.PC->d.ind);\n");
		break;
	case AFP:
		print("\tR.d = (Disdata*) ((char*)R.FP + R.PC->d.ind);\n");
		break;
	case AIMM:
		print("\tR.d = (Disdata*) &R.PC->d.imm;\n");
		break;
	case AMP|AIND:
		if(SOFTMMU) {
			print("R.d = (Disdata*) ((char*)R.MP + R.PC->d.i.f)\n");
			print("R.d = *(WORD**)R.d\n");
			print("R.d = (Disdata*) ((char*)R.d + R.PC->d.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)R.MP + R.PC->d.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t R.d = (Disdata*) (x + R.PC->d.i.s);}\n");
		}
		break;
	case AFP|AIND:
		if(SOFTMMU) {
			print("R.d = (Disdata*) ((char*)R.FP + R.PC->d.i.f)\n");
			print("R.d = *(WORD**)R.d\n");
			print("R.d = (Disdata*) ((char*)R.d + R.PC->d.i.s)\n");
		}
		else {
			print("\t{char* x = *(char**) ( (char*)R.FP + R.PC->d.i.f);\n");
			print("\t if(H==x) error(exNilref);\n");
			print("\t R.d = (Disdata*) (x + R.PC->d.i.s);}\n");
		}
		break;
	}

	if(nodst == 0)
	switch(addr&ARM) {
	case AXNON:
		print("\tR.m = R.d;\n");
		break;
	case AXIMM: /*???*/
		print("\tR.tt = (short) R.PC->reg;\n");
		print("\tR.m = (Disdata*) &R.tt;\n");
		break;
	case AXINF:
		print("\tR.m = (Disdata*) ((char*)R.FP + R.PC->reg);\n");
		break;
	case AXINM:
		print("\tR.m = (Disdata*) ((char*)R.MP + R.PC->reg);\n");
		break;
	}
	print("}\n");
}
