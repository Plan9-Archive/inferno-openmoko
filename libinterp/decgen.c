#include "lib9.h"
#include "isa.h"
#include "interp.h"

void	decgen(int);

/*
 * Force intermediate dereference of $o(o(reg)) modes to ensure intermediate
 * pointer is valid. This is required if you want secure memory.
 */
#define	SOFTMMU		0

int
main(void)
{
	int i;

	print("/* Machine generated by decgen.c */\n\n");

	print("#include \"lib9.h\"\n");
	print("#include \"isa.h\"\n");
	print("#include \"interp.h\"\n\n");
	print("#include \"raise.h\"\n\n");

	/*print("#define DIND(reg, xxx) (uchar*)((*(ulong*)(R.reg+R.PC->xxx.i.f))+R.PC->xxx.i.s)\n");*/

	print("#define DIND(target, reg, xxx){\\\n");
	print(" ulong ul = *(ulong*)(((uchar*)R.reg)+R.PC->xxx.i.f);\\\n");
	print(" if((ulong)H==ul) {error(exNilref);}\\\n");
	print(" R.target = (uchar*)(ul+R.PC->xxx.i.s);\\\n");
	print("}\n");

	for(i = 0; i < 256; i++)
		decgen(i);

	print("\nvoid	(*dec[])(void) =\n{\n");
	for(i = 0; i < 256; i++)
		print("\tD%.2uX%c\n", i, i != 255 ? ',' : ' ');
	print("};\n");
	return 0;
}

void
decgen(int addr)
{
	int nodst;

	print("static void\nD%.2uX(void)\n{\n", addr);

	switch(USRC(addr)) {
	case AMP:
		print("\tR.s = ((uchar*)R.MP)+R.PC->s.ind;\n");
		break;
	case AFP:
		print("\tR.s = ((uchar*)R.FP)+R.PC->s.ind;\n");
		break;
	case AIMM:
		print("\tR.s = (uchar*)&R.PC->s.imm;\n");
		break;
	case AMP|AIND:
		if(SOFTMMU) {
			print("R.s = ((uchar*)R.MP)+R.PC->s.i.f\n");
			print("R.s = *(WORD**)R.s\n");
			print("R.s = (uchar*)R.s + R.PC->s.i.s\n");
		}
		else
			print("\tDIND(s, MP, s);\n");
		break;
	case AFP|AIND:
		if(SOFTMMU) {
			print("R.s = ((uchar*)R.FP)+R.PC->s.i.f\n");
			print("R.s = *(WORD**)R.s\n");
			print("R.s = (uchar*)R.s + R.PC->s.i.s\n");
		}
		else
			print("\tDIND(s, FP, s);\n");
		break;
	}
	nodst = 0;
	switch(UDST(addr)) {
	default:
		nodst = 1;
		break;
	case AMP:
		print("\tR.d = ((uchar*)R.MP)+R.PC->d.ind;\n");
		break;
	case AFP:
		print("\tR.d = ((uchar*)R.FP)+R.PC->d.ind;\n");
		break;
	case AIMM:
		print("\tR.d = (uchar*)&R.PC->d.imm;\n");
		break;
	case AMP|AIND:
		if(SOFTMMU) {
			print("R.d = ((uchar*)R.MP)+R.PC->d.i.f\n");
			print("R.d = *(WORD**)R.d\n");
			print("R.d = (uchar*)R.d + R.PC->d.i.s\n");
		}
		else
			print("\tDIND(d, MP, d);\n");
		break;
	case AFP|AIND:
		if(SOFTMMU) {
			print("R.d = ((uchar*)R.FP)+R.PC->d.i.f\n");
			print("R.d = *(WORD**)R.d\n");
			print("R.d = (uchar*)R.d + R.PC->d.i.s\n");
		}
		else
			print("\tDIND(d, FP, d);\n");
		break;
	}

	if(nodst == 0)
	switch(addr&ARM) {
	case AXNON:
		print("\tR.m = R.d;\n");
		break;
	case AXIMM:
		print("\tR.t = (short)R.PC->reg;\n");
		print("\tR.m = &R.t;\n");
		break;
	case AXINF:
		print("\tR.m = ((uchar*)R.FP)+R.PC->reg;\n");
		break;
	case AXINM:
		print("\tR.m = ((uchar*)R.MP)+R.PC->reg;\n");
		break;
	}
	print("}\n");
}
